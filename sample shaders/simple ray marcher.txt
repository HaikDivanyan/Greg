#define MAX_STEPS 100
#define SURFACE_THRESHOLD 0.01
#define MAX_DIST 100.0



float getDist(vec3 pos){
	float sphere = distance(pos, vec3(0, 1, 2)) - 0.5;
	float plane = pos.y - 0.5;
	return min(plane, sphere);
}

vec3 approximateNormal(vec3 pos) {
	float dist = getDist(pos);
    vec2 epsilon = vec2(0.01, 0);
    
	vec3 normal = dist - vec3(
        getDist(pos-epsilon.xyy),
        getDist(pos-epsilon.yxy),
        getDist(pos-epsilon.yyx));
    
    return normalize(normal);
}

float rayMarch(vec3 origin, vec3 direction){
	float dist = 0.;
	for (int i = 0; i < MAX_STEPS; i++){
		vec3 pos = origin + direction * dist;
		float currDist = getDist(pos);
		dist += currDist;
		if (currDist < SURFACE_THRESHOLD || dist > MAX_DIST) break;
	}
	return dist;
}

vec3 getLighting(vec3 pos, vec3 normal){
	vec4 light1 = vec4(cos(iTime * 3.0), 2.0, 2.0 + 2.0 * sin(iTime * 3.0), 10.0);
	
	float diffuse = clamp(dot(normal, normalize(light1.xyz - pos)), 0.0, 1.0);
	
	if (rayMarch(pos + normal * 2.0 * SURFACE_THRESHOLD, normalize(light1.xyz - pos)) < length(light1.xyz - pos)) diffuse *= 0.1;
	
	return  vec3(1.0, 1.0, 1.0) * diffuse;
}

void mainImage(out vec4 FragColor) {
	vec3 origin = vec3(0, 1, 0);
	vec3 dir = normalize(vec3((gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y, 1.0));
	float dist = rayMarch( vec3(0,1,0), dir);
	vec3 normal = approximateNormal(origin + dist * dir);
	vec3 color = getLighting(origin + dist * dir, normal);
	FragColor = vec4(color, 1);
}