#define MAX_STEPS 100
#define SURFACE_THRESHOLD 0.0001
#define MAX_DIST 100.0

#define Power 8.0

vec2 getDist(vec3 pos) {
	vec3 z = pos;
	float dr = 1.0;
	float r = 0.0;
	int iter = 0;
	for (int i = 0; i < 15 ; i++) {
		r = length(z);
		if (r>2.0) {
			iter = i;
			break;	
		}
		
		float theta = acos(z.z/r) + iTime * 0.1;
		float phi = atan(z.y,z.x);
		dr =  pow( r, Power-1.0)*Power*dr + 1.0;
		
		float zr = pow( r,Power);
		theta = theta*Power;
		phi = phi*Power;
		
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=pos;
	}
	return vec2(0.5*log(r)*r/dr, iter);
}

vec3 approximateNormal(vec3 pos) {
	float dist = getDist(pos).x;
    vec2 epsilon = vec2(0.0001, 0);
    
	vec3 normal = dist - vec3(
        getDist(pos-epsilon.xyy).x,
        getDist(pos-epsilon.yxy).x,
        getDist(pos-epsilon.yyx).x);
    
    return normalize(normal);
}

vec3 rayMarch(vec3 origin, vec3 direction){
	vec3 grad = vec3(0, 0, 0);
	vec3 light = vec3(1. + sin(iTime), 2, 3. + cos(iTime));
	float dist = 0.0;
	for (int i = 0; i < MAX_STEPS; i++){
		vec3 pos = origin + direction * dist;
		vec2 currDist = getDist(pos);
		dist += currDist.x;
		if (currDist.x < SURFACE_THRESHOLD){
			float A = clamp(dot(approximateNormal(origin + direction * dist) * 0.5 + 0.5, pos - light), 0.0, 1.0);
			float B = clamp(currDist.y / 10.0, 0.0, 1.0);
			grad = clamp(1.5 * B * vec3(77, 0, 64) / 255.0 + A * vec3(255, 77, 255) / 255.0, 0.0, 1.0);
			break;
		}
		if (dist > MAX_DIST) break;
	}
	return grad;
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
{
	vec3 cw = normalize(ta-ro);
	vec3 cp = vec3(sin(cr), cos(cr),0.0);
	vec3 cu = normalize( cross(cw,cp) );
	vec3 cv =          ( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void mainImage(out vec4 FragColor) {
	float time = 32.0 + iTime*1.5;
	const float fl = 3.5;
    vec3 ta = vec3( 0.5, -0.5, -0.6 );
	vec3 ro = ta + vec3( 0.5, -1.0, -1.0 - sin(iTime * 0.2));
    mat3 ca = setCamera( ro, ta, 0.0 );
	vec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;
	vec3 rd = ca * normalize( vec3(p,fl) );
	
	vec3 col = rayMarch( ro, rd) * 2.5;
	FragColor = vec4(col, 1);
}